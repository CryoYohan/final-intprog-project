{"ast":null,"code":"import { BehaviorSubject, throwError } from 'rxjs';\nimport { map, finalize, catchError } from 'rxjs/operators';\nimport { environment } from '@environments/environment';\nimport { Role } from '@app/_models';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/router\";\nimport * as i2 from \"@angular/common/http\";\nconst baseUrl = `${environment.apiUrl}/accounts`;\nexport let AccountService = /*#__PURE__*/(() => {\n  class AccountService {\n    constructor(router, http) {\n      this.router = router;\n      this.http = http;\n      this.refreshingToken = false;\n      this.TOKEN_REFRESH_THRESHOLD = 5 * 60 * 1000; // 5 minutes in milliseconds\n      this.accountSubject = new BehaviorSubject(null);\n      this.account = this.accountSubject.asObservable();\n      this.loadStoredAccount();\n    }\n    loadStoredAccount() {\n      try {\n        const storedAccount = localStorage.getItem('account');\n        if (storedAccount) {\n          const account = JSON.parse(storedAccount);\n          if (this.isTokenValid(account)) {\n            this.accountSubject.next(account);\n            this.startRefreshTokenTimer();\n          } else {\n            // Token is expired or invalid, try to refresh\n            this.refreshToken().subscribe();\n          }\n        }\n      } catch (error) {\n        console.error('Error loading stored account:', error);\n        localStorage.removeItem('account');\n      }\n    }\n    isTokenValid(account) {\n      if (!account || !account.jwtToken) return false;\n      try {\n        const token = account.jwtToken;\n        const tokenData = JSON.parse(atob(token.split('.')[1]));\n        const expirationTime = tokenData.exp * 1000; // Convert to milliseconds\n        // Check if token is expired or about to expire\n        return Date.now() < expirationTime - this.TOKEN_REFRESH_THRESHOLD;\n      } catch (_a) {\n        return false;\n      }\n    }\n    get accountValue() {\n      return this.accountSubject.value;\n    }\n    get userValue() {\n      return this.accountValue;\n    }\n    get isAdmin() {\n      var _a;\n      return ((_a = this.accountValue) === null || _a === void 0 ? void 0 : _a.role) === Role.Admin;\n    }\n    login(email, password) {\n      return this.http.post(`${baseUrl}/authenticate`, {\n        email,\n        password\n      }, {\n        withCredentials: true\n      }).pipe(map(account => {\n        this.storeAccount(account);\n        this.startRefreshTokenTimer();\n        return account;\n      }), catchError(error => {\n        console.error('Login error:', error);\n        return throwError(() => error);\n      }));\n    }\n    storeAccount(account) {\n      localStorage.setItem('account', JSON.stringify(account));\n      this.accountSubject.next(account);\n    }\n    logout() {\n      this.http.post(`${baseUrl}/revoke-token`, {}, {\n        withCredentials: true\n      }).pipe(finalize(() => {\n        this.clearAccountData();\n      })).subscribe();\n    }\n    clearAccountData() {\n      localStorage.removeItem('account');\n      this.stopRefreshTokenTimer();\n      this.accountSubject.next(null);\n      this.router.navigate(['/account/login']);\n    }\n    refreshToken() {\n      if (this.refreshingToken) {\n        return this.account;\n      }\n      this.refreshingToken = true;\n      return this.http.post(`${baseUrl}/refresh-token`, {}, {\n        withCredentials: true,\n        headers: {\n          'Cache-Control': 'no-cache',\n          'Pragma': 'no-cache'\n        }\n      }).pipe(map(account => {\n        if (!account || !account.jwtToken) {\n          throw new Error('Invalid refresh token response');\n        }\n        this.storeAccount(account);\n        this.startRefreshTokenTimer();\n        return account;\n      }), catchError(error => {\n        console.error('Token refresh failed:', error);\n        this.clearAccountData();\n        return throwError(() => new Error('Session expired. Please login again.'));\n      }), finalize(() => {\n        this.refreshingToken = false;\n      }));\n    }\n    register(account) {\n      return this.http.post(`${baseUrl}/register`, account, {\n        observe: 'response'\n      });\n    }\n    verifyEmail(token) {\n      return this.http.post(`${baseUrl}/verify-email`, {\n        token\n      });\n    }\n    forgotPassword(email) {\n      return this.http.post(`${baseUrl}/forgot-password`, {\n        email\n      });\n    }\n    validateResetToken(token) {\n      return this.http.post(`${baseUrl}/validate-reset-token`, {\n        token\n      });\n    }\n    resetPassword(token, password, confirmPassword) {\n      return this.http.post(`${baseUrl}/reset-password`, {\n        token,\n        password,\n        confirmPassword\n      });\n    }\n    getAll() {\n      return this.http.get(baseUrl);\n    }\n    getById(id) {\n      return this.http.get(`${baseUrl}/${id}`);\n    }\n    create(params) {\n      return this.http.post(baseUrl, params);\n    }\n    update(id, params) {\n      return this.http.put(`${baseUrl}/${id}`, params).pipe(map(account => {\n        var _a;\n        // update the current account if it was updated\n        if (account.id === ((_a = this.accountValue) === null || _a === void 0 ? void 0 : _a.id)) {\n          // publish updated account to subscribers\n          account = Object.assign(Object.assign({}, this.accountValue), account);\n          this.accountSubject.next(account);\n        }\n        return account;\n      }));\n    }\n    delete(id) {\n      return this.http.delete(`${baseUrl}/${id}`).pipe(map(x => {\n        var _a;\n        // auto logout if the logged in account was deleted\n        if (id === ((_a = this.accountValue) === null || _a === void 0 ? void 0 : _a.id)) {\n          this.logout();\n        }\n        return x;\n      }));\n    }\n    startRefreshTokenTimer() {\n      var _a;\n      if (!((_a = this.accountValue) === null || _a === void 0 ? void 0 : _a.jwtToken)) return;\n      try {\n        // Parse the JWT token to get expiration time\n        const token = this.accountValue.jwtToken;\n        const tokenData = JSON.parse(atob(token.split('.')[1]));\n        const expires = new Date(tokenData.exp * 1000);\n        const timeout = expires.getTime() - Date.now() - this.TOKEN_REFRESH_THRESHOLD;\n        // Set up refresh timer\n        this.stopRefreshTokenTimer();\n        if (timeout > 0) {\n          this.refreshTokenTimeout = setTimeout(() => {\n            console.log('Token refresh timer triggered');\n            this.refreshToken().subscribe({\n              error: error => {\n                console.error('Auto refresh token failed:', error);\n                this.clearAccountData();\n              }\n            });\n          }, timeout);\n        } else {\n          // Token is already expired or about to expire, refresh immediately\n          this.refreshToken().subscribe({\n            error: error => {\n              console.error('Immediate token refresh failed:', error);\n              this.clearAccountData();\n            }\n          });\n        }\n      } catch (error) {\n        console.error('Error starting refresh token timer:', error);\n        this.clearAccountData();\n      }\n    }\n    stopRefreshTokenTimer() {\n      if (this.refreshTokenTimeout) {\n        clearTimeout(this.refreshTokenTimeout);\n      }\n    }\n  }\n  AccountService.ɵfac = function AccountService_Factory(t) {\n    return new (t || AccountService)(i0.ɵɵinject(i1.Router), i0.ɵɵinject(i2.HttpClient));\n  };\n  AccountService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AccountService,\n    factory: AccountService.ɵfac,\n    providedIn: 'root'\n  });\n  return AccountService;\n})();","map":{"version":3,"mappings":"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","names":["BehaviorSubject","throwError","map","finalize","catchError","environment","Role","baseUrl","apiUrl","AccountService","constructor","router","http","accountSubject","account","asObservable","loadStoredAccount","storedAccount","localStorage","getItem","JSON","parse","isTokenValid","next","startRefreshTokenTimer","refreshToken","subscribe","error","console","removeItem","jwtToken","token","tokenData","atob","split","expirationTime","exp","Date","now","TOKEN_REFRESH_THRESHOLD","accountValue","value","userValue","isAdmin","role","Admin","login","email","password","post","withCredentials","pipe","storeAccount","setItem","stringify","logout","clearAccountData","stopRefreshTokenTimer","navigate","refreshingToken","headers","Error","register","observe","verifyEmail","forgotPassword","validateResetToken","resetPassword","confirmPassword","getAll","get","getById","id","create","params","update","put","delete","x","expires","timeout","getTime","refreshTokenTimeout","setTimeout","log","clearTimeout","factory","providedIn"],"sourceRoot":"","sources":["D:\\JiM\\School\\3rd Year\\2nd Semester\\SUBJECTS\\IT-INTPROG32\\Coding (INTPROG32)\\Final\\project6\\frontend\\src\\app\\_services\\account.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { HttpClient, HttpResponse, HttpHeaders } from '@angular/common/http';\nimport { BehaviorSubject, Observable, throwError } from 'rxjs';\nimport { map, finalize, catchError } from 'rxjs/operators';\nimport { environment } from '@environments/environment';\nimport { Account, Role, RegistrationResponse } from '@app/_models';\n\nconst baseUrl = `${environment.apiUrl}/accounts`;\n\n@Injectable({ providedIn: 'root' })\nexport class AccountService {\n    private accountSubject: BehaviorSubject<Account | null>;\n    public account: Observable<Account | null>;\n    private refreshTokenTimeout: any;\n    private refreshingToken = false;\n    private readonly TOKEN_REFRESH_THRESHOLD = 5 * 60 * 1000; // 5 minutes in milliseconds\n\n    constructor(\n        private router: Router,\n        private http: HttpClient\n    ) {\n        this.accountSubject = new BehaviorSubject<Account | null>(null);\n        this.account = this.accountSubject.asObservable();\n        this.loadStoredAccount();\n    }\n\n    private loadStoredAccount() {\n        try {\n            const storedAccount = localStorage.getItem('account');\n            if (storedAccount) {\n                const account = JSON.parse(storedAccount);\n                if (this.isTokenValid(account)) {\n                    this.accountSubject.next(account);\n                    this.startRefreshTokenTimer();\n                } else {\n                    // Token is expired or invalid, try to refresh\n                    this.refreshToken().subscribe();\n                }\n            }\n        } catch (error) {\n            console.error('Error loading stored account:', error);\n            localStorage.removeItem('account');\n        }\n    }\n\n    public isTokenValid(account: Account): boolean {\n        if (!account || !account.jwtToken) return false;\n        \n        try {\n            const token = account.jwtToken;\n            const tokenData = JSON.parse(atob(token.split('.')[1]));\n            const expirationTime = tokenData.exp * 1000; // Convert to milliseconds\n            \n            // Check if token is expired or about to expire\n            return Date.now() < (expirationTime - this.TOKEN_REFRESH_THRESHOLD);\n        } catch {\n            return false;\n        }\n    }\n\n    public get accountValue() {\n        return this.accountSubject.value;\n    }\n\n    public get userValue() {\n        return this.accountValue;\n    }\n\n    public get isAdmin() {\n        return this.accountValue?.role === Role.Admin;\n    }\n\n    login(email: string, password: string) {\n        return this.http.post<Account>(`${baseUrl}/authenticate`, { email, password }, { withCredentials: true })\n            .pipe(\n                map(account => {\n                    this.storeAccount(account);\n                    this.startRefreshTokenTimer();\n                    return account;\n                }),\n                catchError(error => {\n                    console.error('Login error:', error);\n                    return throwError(() => error);\n                })\n            );\n    }\n\n    private storeAccount(account: Account) {\n        localStorage.setItem('account', JSON.stringify(account));\n        this.accountSubject.next(account);\n    }\n\n    logout() {\n        this.http.post<any>(`${baseUrl}/revoke-token`, {}, { withCredentials: true })\n            .pipe(\n                finalize(() => {\n                    this.clearAccountData();\n                })\n            )\n            .subscribe();\n    }\n\n    public clearAccountData() {\n        localStorage.removeItem('account');\n        this.stopRefreshTokenTimer();\n        this.accountSubject.next(null);\n        this.router.navigate(['/account/login']);\n    }\n\n    refreshToken() {\n        if (this.refreshingToken) {\n            return this.account;\n        }\n\n        this.refreshingToken = true;\n        return this.http.post<Account>(`${baseUrl}/refresh-token`, {}, { \n            withCredentials: true,\n            headers: {\n                'Cache-Control': 'no-cache',\n                'Pragma': 'no-cache'\n            }\n        }).pipe(\n            map(account => {\n                if (!account || !account.jwtToken) {\n                    throw new Error('Invalid refresh token response');\n                }\n                this.storeAccount(account);\n                this.startRefreshTokenTimer();\n                return account;\n            }),\n            catchError(error => {\n                console.error('Token refresh failed:', error);\n                this.clearAccountData();\n                return throwError(() => new Error('Session expired. Please login again.'));\n            }),\n            finalize(() => {\n                this.refreshingToken = false;\n            })\n        );\n    }\n\n    register(account: Account): Observable<HttpResponse<RegistrationResponse>> {\n        return this.http.post<RegistrationResponse>(`${baseUrl}/register`, account, { observe: 'response' });\n    }\n\n    verifyEmail(token: string) {\n        return this.http.post(`${baseUrl}/verify-email`, { token });\n    }\n\n    forgotPassword(email: string) {\n        return this.http.post(`${baseUrl}/forgot-password`, { email });\n    }\n\n    validateResetToken(token: string) {\n        return this.http.post(`${baseUrl}/validate-reset-token`, { token });\n    }\n\n    resetPassword(token: string, password: string, confirmPassword: string) {\n        return this.http.post(`${baseUrl}/reset-password`, { token, password, confirmPassword });\n    }\n\n    getAll() {\n        return this.http.get<Account[]>(baseUrl);\n    }\n\n    getById(id: string) {\n        return this.http.get<Account>(`${baseUrl}/${id}`);\n    }\n\n    create(params: any) {\n        return this.http.post(baseUrl, params);\n    }\n\n    update(id: string, params: any) {\n        return this.http.put(`${baseUrl}/${id}`, params)\n            .pipe(map((account: any) => {\n                // update the current account if it was updated\n                if (account.id === this.accountValue?.id) {\n                    // publish updated account to subscribers\n                    account = { ...this.accountValue, ...account };\n                    this.accountSubject.next(account);\n                }\n                return account;\n            }));\n    }\n\n    delete(id: string) {\n        return this.http.delete(`${baseUrl}/${id}`)\n            .pipe(map(x => {\n                // auto logout if the logged in account was deleted\n                if (id === this.accountValue?.id) {\n                    this.logout();\n                }\n                return x;\n            }));\n    }\n\n    private startRefreshTokenTimer() {\n        if (!this.accountValue?.jwtToken) return;\n\n        try {\n            // Parse the JWT token to get expiration time\n            const token = this.accountValue.jwtToken;\n            const tokenData = JSON.parse(atob(token.split('.')[1]));\n            const expires = new Date(tokenData.exp * 1000);\n            const timeout = expires.getTime() - Date.now() - this.TOKEN_REFRESH_THRESHOLD;\n\n            // Set up refresh timer\n            this.stopRefreshTokenTimer();\n            if (timeout > 0) {\n                this.refreshTokenTimeout = setTimeout(() => {\n                    console.log('Token refresh timer triggered');\n                    this.refreshToken().subscribe({\n                        error: (error) => {\n                            console.error('Auto refresh token failed:', error);\n                            this.clearAccountData();\n                        }\n                    });\n                }, timeout);\n            } else {\n                // Token is already expired or about to expire, refresh immediately\n                this.refreshToken().subscribe({\n                    error: (error) => {\n                        console.error('Immediate token refresh failed:', error);\n                        this.clearAccountData();\n                    }\n                });\n            }\n        } catch (error) {\n            console.error('Error starting refresh token timer:', error);\n            this.clearAccountData();\n        }\n    }\n\n    private stopRefreshTokenTimer() {\n        if (this.refreshTokenTimeout) {\n            clearTimeout(this.refreshTokenTimeout);\n        }\n    }\n}"]},"metadata":{},"sourceType":"module","externalDependencies":[]}